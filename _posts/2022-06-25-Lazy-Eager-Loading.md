---
title: "[JPA ORM] 지연 로딩(LAZY)과 즉시 로딩(EAGER)"
date: 2022-06-25 12:07:08
categories: JPA ORM Proxy Lazy Eager
---

## 지연 로딩(Lazy), 즉시 로딩(Eager)이란?

이전 글에서 프록시(Proxy)의 개념에 대해서 설명하였다. 프록시에 대해 이해한다면 지연 로딩의 동작에 대해 바로 이해할 수 있을 것이다. 

Member class와 연관관계 매핑 되어있는 Team class에 대해 생각해보자. Member 와 Team은 ManyToOne 관계로 매핑되어 있을 것이다. 그런데 비즈니스 로직 상 Member 객체를 조회하면서 Team을 참조하게 될 필요는 전혀 없다. 따라서 Member 객체를 조회할 때마다 Team 테이블을 join 해서 가져오는 것은 성능상 낭비가 될 것이다. 

여기에 프록시 개념을 도입한다면 쉽게 해결할 수 있지 않을까? Member 객체를 조회하면서 실제로 Team 에 대한 접근을 하기 전까지 프록시 객체를 두어 데이터베이스 조회를 미룬다면 문제를 쉽게 해결할 수 있다. Spring에서는 `@ManyToOne(fetch = FetchType.LAZY)` 어노테이션으로 설정하여 구현할 수 있다.

즉시 로딩(Eager) 란 지연 로딩과 반대로 참조하는 객체와 연관된 매핑을 join으로 항상 조회하는 방법이다. Spring에서는 `@ManyToOne(fetch = FetchType.Eager)` 어노테이션으로 설정하여 구현할 수 있다.

<img width="611" alt="image" src="https://user-images.githubusercontent.com/73485743/175666516-7d0f2cac-3254-47c7-b3a0-447f9058e5ce.png">

- - -

## 지연 로딩(Lazy) 만을 사용해야 하는 이유

그렇지만 결론부터 말하자면, 실무에서는 즉시 로딩을 사용하는 것은 상당히 좋지 않다. 즉, 가급적 지연 로딩만 사용해야 된다.

그 이유는 즉시 로딩을 사용하면 JPQL에서 **N+1 문제**를 일으키기 때문이다. 

JPQL은 우선 SQL로 번역되어 DB에 쿼리 형태로 나가기 때문에, 만약 Member 객체를 조회하면 각 데이터에 대해 Team 객체를 계속해서 조회해야 한다. 하나의 쿼리 때문에 N개의 쿼리가 더 발생한다는 뜻에서 N+1문제라 부른다. 

즉, 여기서 핵심은 테이블 간 연관관계가 매우 복잡하게 얽혀 있는 실무 프로젝트에서는 이 문제가 성능에 critical한 문제를 일으킬 수 있는 것이 즉시 로딩을 지양하는 이유이다. 

또한 개발자가 의도한 코드에서 예상치 못한 SQL 쿼리가 많이 발생하게 되어 오류 잡기가 곤란해지는 이유도 있다.

- - -

## 즉시 로딩이 유리한 경우의 대처법

하지만 비즈니스 로직 상 Member 객체를 조회할 때 항상 Team 객체를 접근해야 한다면 즉시로딩을 사용해서 미리 가져오는 것이 훨씬 유리할 것이다. 그러나 앞서 지연 로딩(Lazy)을 기본으로 사용해야 한다고 했다. 그러면 만약 위와 같은 상황에서는 어떻게 대처해야 할까?

크게 3가지 방법이 존재한다. 여기서는 각각의 방법에 대해 구체적으로 설명하지 않고 소개만 하려고 한다.

- JPQL fetch join을 이용하는 방법
- Entity graph 기능을 사용하는 방법
- Annotation 을 사용하는 방법

- - -
**참고 강의안:** 인프런 김영한님 강의안, 자바 ORM 표준 JPA 프로그래밍 - 기본편 중 08.프록시와 연관관계 관리.pdf
